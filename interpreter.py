from lexer import Lexer
from parser import Parser, Number, Bool, Identifier, BinaryOp, FunctionDef, FunctionCall, UnaryOp, Lambda
from errors import InterpreterError


class Environment:
    """
    Class representing an environment for variable/function storage.
    Supports nested environments for function scopes.

    Attributes:
        parent (Environment): The parent environment, if any.
        variables (dict): A dictionary mapping variable/function names to their values.
    """

    def __init__(self, parent=None):
        """
        Initializes an Environment with an optional parent.

        Parameters:
            parent (Environment, optional): The parent environment. Defaults to None.
        """
        self.parent = parent
        self.variables = {}

    def define(self, name, value):
        """
        Defines a new variable or function in the current environment.

        Parameters:
            name (str): The name of the variable or function.
            value: The value or function associated with the name.
        """
        self.variables[name] = value

    def lookup(self, name):
        """
        Looks up a variable or function by name in the current and parent environments.

        Parameters:
            name (str): The name of the variable or function to look up.

        Returns:
            The value associated with the name.

        Raises:
            NameError: If the name is not found in the current or any parent environment.
        """
        if name in self.variables:
            return self.variables[name]
        if self.parent:
            return self.parent.lookup(name)
        raise NameError(f"Name '{name}' is not defined")


class Interpreter:
    """
    The Interpreter class evaluates the Abstract Syntax Tree (AST) generated by the parser.
    It executes the code represented by the AST nodes.

    Attributes:
        global_env (Environment): The global environment where variables and functions are stored.
        code_lines (list): A list of code lines, used for error reporting.
    """

    def __init__(self):
        """
        Initializes the Interpreter with a global environment and an empty code line list.
        """
        self.global_env = Environment()
        self.code_lines = []  # Store the lines of code

    def set_code(self, code):
        """
        Sets the code to be evaluated, splitting it into lines for error reporting.

        Parameters:
            code (str): The source code to evaluate.
        """
        self.code_lines = code.split('\n')

    def get_context(self, node):
        """
        Retrieves the context around a node for error reporting.

        Parameters:
            node (ASTNode): The node for which context is needed.

        Returns:
            str: A string representing the line of code where the node is found.
        """
        if hasattr(node, 'line') and hasattr(node, 'column'):
            if 0 <= node.line - 1 < len(self.code_lines):
                line = self.code_lines[node.line - 1]
                return f"Line {node.line}: {line}\n" + " " * (node.column + 6) + "^"
            else:
                return f"Line {node.line}: <line not available>"
        return None

    def evaluate(self, node, env=None):
        """
        Evaluates a given AST node within the provided environment.

        Parameters:
            node (ASTNode): The AST node to evaluate.
            env (Environment, optional): The environment in which to evaluate the node.
                                         If not provided, the global environment will be used.

        Returns:
            The result of evaluating the AST node.

        Raises:
            InterpreterError: If there is an error during evaluation, such as a runtime error.
        """
        if env is None:
            env = self.global_env

        try:
            if isinstance(node, Number):
                return node.value
            elif isinstance(node, Bool):
                return node.value
            elif isinstance(node, Identifier):
                return env.lookup(node.name)
            elif isinstance(node, BinaryOp):
                return self.eval_binary_op(node, env)
            elif isinstance(node, UnaryOp):
                return self.eval_unary_op(node, env)
            elif isinstance(node, FunctionDef):
                return self.eval_function_def(node, env)
            elif isinstance(node, FunctionCall):
                return self.eval_function_call(node, env)
            elif isinstance(node, Lambda):
                return self.eval_lambda(node, env)
            else:
                raise TypeError(f"Unknown node type: {type(node)}")
        except Exception as e:
            context = self.get_context(node)
            raise InterpreterError(str(e), node.line, node.column, context)

    def eval_binary_op(self, node, env):
        """
        Evaluates a binary operation (e.g., addition, subtraction).

        Parameters:
            node (BinaryOp): The binary operation node to evaluate.
            env (Environment): The environment in which to evaluate the operation.

        Returns:
            The result of the binary operation.

        Raises:
            InterpreterError: If there is a runtime error during evaluation, such as division by zero.
        """
        left = self.evaluate(node.left, env)

        # Short-circuit evaluation for 'and' and 'or'
        if node.op == 'or':
            if left:
                return left
            return self.evaluate(node.right, env)
        elif node.op == 'and':
            if not left:
                return left
            return self.evaluate(node.right, env)

        right = self.evaluate(node.right, env)

        if node.op == '+':
            return left + right
        elif node.op == '-':
            return left - right
        elif node.op == '*':
            return left * right
        elif node.op == '/':
            if right == 0:
                context = self.get_context(node)
                raise InterpreterError("Division by zero", node.line, node.column, context)
            return left // right  # Integer division
        elif node.op == '%':
            if right == 0:
                context = self.get_context(node)
                raise InterpreterError("Modulo by zero", node.line, node.column, context)
            return left % right
        elif node.op == '==':
            return left == right
        elif node.op == '!=':
            return left != right
        elif node.op == '<':
            return left < right
        elif node.op == '<=':
            return left <= right
        elif node.op == '>':
            return left > right
        elif node.op == '>=':
            return left >= right
        else:
            context = self.get_context(node)
            raise InterpreterError(f"Unknown operator: {node.op}", node.line, node.column, context)

    def eval_unary_op(self, node, env):
        """
        Evaluates a unary operation (e.g., negation, logical NOT).

        Parameters:
            node (UnaryOp): The unary operation node to evaluate.
            env (Environment): The environment in which to evaluate the operation.

        Returns:
            The result of the unary operation.

        Raises:
            InterpreterError: If there is a runtime error during evaluation, such as an unknown operator.
        """
        operand = self.evaluate(node.operand, env)
        if node.op == 'not':
            return not operand
        context = self.get_context(node)
        raise InterpreterError(f"Unknown unary operator: {node.op}", node.line, node.column, context)

    def eval_function_def(self, node, env):
        """
        Evaluates a function definition, adding it to the environment.

        Parameters:
            node (FunctionDef): The function definition node to evaluate.
            env (Environment): The environment in which to define the function.

        Returns:
            str: A message indicating that the function was defined.

        Raises:
            InterpreterError: If there is an error during function definition, such as undefined variables.
        """
        try:
            self.check_undefined_variables(node.body, set(node.params), env)
        except NameError as e:
            context = self.get_context(node)
            raise InterpreterError(str(e), node.line, node.column, context)

        def func(*args):
            local_env = Environment(env)
            for param, arg in zip(node.params, args):
                local_env.define(param, arg)
            return self.evaluate(node.body, local_env)

        env.define(node.name, func)
        return f"Function '{node.name}' defined"

    def check_undefined_variables(self, node, defined_vars, env):
        """
        Helper function to ensure no undefined variables are used in the function body.

        Parameters:
            node (ASTNode): The node to check for undefined variables.
            defined_vars (set): A set of defined variable names.
            env (Environment): The environment to check for variable definitions.

        Raises:
            NameError: If an undefined variable is used in the function body.
        """
        if isinstance(node, Identifier):
            if node.name not in defined_vars and env.lookup(node.name) is None:
                raise NameError(f"Undefined variable '{node.name}' in function body")
        elif isinstance(node, BinaryOp):
            self.check_undefined_variables(node.left, defined_vars, env)
            self.check_undefined_variables(node.right, defined_vars, env)
        elif isinstance(node, UnaryOp):
            self.check_undefined_variables(node.operand, defined_vars, env)
        elif isinstance(node, FunctionCall):
            for arg in node.args:
                self.check_undefined_variables(arg, defined_vars, env)

    def eval_function_call(self, node, env):
        """
        Evaluates a function call, applying the function to the provided arguments.

        Parameters:
            node (FunctionCall): The function call node to evaluate.
            env (Environment): The environment in which to evaluate the function call.

        Returns:
            The result of the function call.

        Raises:
            InterpreterError: If there is an error during function application, such as an undefined function.
        """
        if isinstance(node.name, Lambda):
            func = self.eval_lambda(node.name, env)
        else:
            func = env.lookup(node.name)
        args = [self.evaluate(arg, env) for arg in node.args]
        return func(*args)

    def eval_lambda(self, node, env):
        """
        Evaluates a lambda expression, creating a new function.

        Parameters:
            node (Lambda): The lambda expression node to evaluate.
            env (Environment): The environment in which to evaluate the lambda expression.

        Returns:
            function: A callable function object representing the lambda expression.
        """

        def func(*args):
            local_env = Environment(env)
            for param, arg in zip(node.params, args):
                local_env.define(param, arg)
            return self.evaluate(node.body, local_env)

        return func
